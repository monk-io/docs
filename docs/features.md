# Features

This page describes primary Monk features and points to relevant resources for each of them.

:::note

The ðŸ§ªâ€‹ icon denotes experimental features. Please don't be upset if they cause problems and [let us know](support.md) if you encounter any bugs related to those.

:::

## Supported Cloud Providers

-   GCP
-   AWS
-   Azure
-   DigitalOcean

## MonkScript

Our language allows you to specify your entire stack needs in a simple, reusable way. MonkScript is a primary user interface for controlling Monk's Programmable Control Plane. [Here's a primer &#8594;
](monkscript)

### Programmable Control Plane

Monk understands your workloads by constantly tracking and computing values associated with any cloud instance, running container, firewall rule, data volume, and all other items present in a cluster. This process is scriptable directly from the templates, which makes it easy to express even the most complex workloads.

### Custom Variables

Expose your container environment variables through dynamically computed variables, add and edit as required to extend your component functionality. [Read more &#8594;
](monkscript/yaml/runnables#variables)â€‹

### Actions

Abstract any of your containerized software functionalities through our unique actions within the same template. [Read moreâ€‹ &#8594;
](monkscript/yaml/runnables#actions)

### Health Checks

Simplify container calls outside the cluster and easily implement specific health-checks.

### Service Discovery

Seamlessly integrate your services to discover and talk to each other with one line of code.

### Container Data Introspection

Inspect any data generated by your services by directly calling and extracting it via `monk` CLI.

### ðŸ§ª Life Cycle Hooks & Auto-scaling

Define cluster and container events. Anything from changing container variables to the whole cluster scaling strategies. For provisioning, [start learning here](provisioning-via-templates), or check out [hooks](hooks.md).

### Placement Constraints for Containers

Define explicit deployment of your architecture. Depending on your architecture, your services may need an explicitly defined deployment to ensure they are using an instance on their own, are on instances close to other services, or exactly on the same one as them.

### ðŸ§ª Encrypted at Rest

No need for special handling when it comes to secrets. Monk will load SOPS-encrypted YAML and store all the values re-encrypted in a cluster-wide vault by default. [SOPS guide &#8594;
](passing-secrets.md)

## Interfaces: CLI / GUI

### Remote Log Streaming

Instantly inspect your services logs via our CLI or GUI without any 3rd party tools, needing to ssh to instances or finding out where they are deployed.

### Built-in CPU/MEM/Disk stats

Instantly inspect your cluster instances utilization directly from our CLI or GUI.

### Shell Access to/from Any Container

Directly access shell of any running container from our CLI, without ssh to its instance or needing to find out where they are running.

## Orchestration

### System Portability to Any Cloud Provider

The Monk runtime natively runs on any Linux instance. You can create clusters spanning across any cloud or on-premise server while ensuring your template will stay portable.

### Workload Healing on Container and Instance Level

Our orchestration engine constantly ensures that the cluster and container state is preserved and in the event of down time or service failure it will aim to restore the state.

### Automatic, State-Preserving Updates of the Containers, Including Dependencies

Monk is aware of changes happening to each part. Therefore you can easily perform updates with a single line command.

### ðŸ§ª Auto-scaling

Implement horizontal and vertical scaling strategies to keep your system growing.

### ðŸ§ª Built-in Container Image Transport

For deployment of private images within a cluster, our architecture allows for much faster of container images inside the cluster, speeding up deployment and repair processes.

## Infrastructure Provisioning

Automatic provisioning of resources such as instances, EBS-type volumes, load balancers, and security groups. Monk engine takes care of all the complexity of provisioning different parts of cloud infrastructure that your system needs.

## Service Abstraction

### Cloud Load Balancers

Utilize the most popular load balancers (HTTP(s) and ElasticIP) natively baked in and easily definable by our language. [Load balancers &#8594;
](load-balancers.md)

### ðŸ§ª 3rd Party Service Abstraction

Include any 3rd party services such as specific Cloud APIs in templates with similar scripting capabilities. Our language can also be used to embed third party services such as SaaS APIs or directly into your system. [Compose a small system](basic-app.md) to see how it works.

### ðŸ§ª Network Abstraction

Encrypted overlay network between the containers with fully automated internet-facing firewall control.

Our orchestration comes with security baked in. Containers can securely communicate with each other, as per your defined criteria, and all secrets all encrypted except when needed. [Connecting runnables &#8594;
](connecting-runnables.md)

## Access Control

### Multiple Users Cluster Access

Allow multiple users within your organization to perform operations on your running clusters. Regulate types of access to running Monk clusters resources based on the roles of individual users within your organization. [Contact us &#8594;
](https://monk-io.typeform.com/to/Wd9BokCb)

## CI/CD support

Integrate your stack deployment with your favorite CI/CD tools and deploy to your Monk clusters. Currently supporting:

-   CircleCI
-   Github Actions
-   GitLab CI

See the [CI/CD Guide&#8594;
](ci-cd)
